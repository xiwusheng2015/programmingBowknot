MySQL四十五讲：


## 1 一条查询日志怎样执行的，
- 查询语句
## 2 一条更新语句怎样执行，
- 相关的日志模块知识
- crash-safe的能力
- 为什么会有两份日志
## 03 讲事务隔离：为什么你改了我还看不见
- 事务的四个隔离级别讲解
- 事务隔离的实现
- 同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）为什么建议你尽量不要使用长事务
- 事务的启动方式
## 04讲深入浅出索引（上）
- 索引的常见模型
- 使用“N叉”树，这个N差不多是1200
- InnoDB 的索引模型
- 基于主键索引和普通索引的查询有什么区别
- 索引维护：建表语句里一定要有自增主键
## 05讲深入浅出索引（下）
- 回到主键索引树搜索的过程，我们称为回表
- 覆盖索引：避免回表
- 联合索引，最左前缀原则
- 回表，覆盖索引
- 最左前缀
- 索引下推
## 06讲全局锁和表锁：给表加个字段怎么有这么多阻碍
- 全局锁和表级锁现象和背后的原理
- 加全局锁Flush tables with read lock （FTWRL）
- 逻辑备份工具是mysqldump
- 表锁和元数据锁（更改表结构时候使用）
- 事务中的MDL锁，语句结束后不会马上释放
## 07讲行锁功过：怎么减少行锁对性能的影响
- 两阶段锁
- 行锁也不是立刻释放的
- 死锁和死锁检测
## 08讲事务到底是隔离的还是不隔离的
- start transaction 命令并不是一个事务的起点，第一个读语句执行事务才开始可以使用start transaction with consistent snapshot 这个命令。
- “快照”在MVCC里是怎么工作的？
- 事务A的一致性读
- 更新数据都是先读后写，称为“当前读”
- 读锁 lock in share mode 写锁 for update
- 事务的可重复读的能力是怎么实现的，核心是一致性读，事务更新时，只能当前读
•


## B树和B+树读区别

binlog格式的区别
存储过程

nginx面试题
reentrentlock+aqs


## 15讲答疑文章（一）：日志和索引相关问题
## 16讲“orderby”是怎么工作的
• 全字段排序
• sort_buffer_size 控制是否在内存还是需要磁盘临时文件
• 如果MySQL认为排序的单行长度太大会怎么做，只有要排序的列（即name字段）和主键id  参数: max_length_for_sort_dat
• 全字段排序 VS rowid排序
• city,name 使用联合索引不需要排序
• binlog_format=statement
## 17讲如何正确地显示随机消息
• 随机排序需求
• 内存临时表，磁盘临时表
• limit取的值比较小，使用优先队列排序，不用磁盘临时文件
• 随机排序方法
## 18讲为什么这些SQL语句逻辑相同，性能却差异巨大
• 字段上有函数运算，破坏索引值有序性，不再使用索引
• 隐式类型转换
• 隐式字符编码转换
## 19讲为什么我只查一行的语句，也执行这么慢
• show processlist 查看当前语句状态
• 等MDL锁
• 等flush
• 等行锁



















